\documentclass[12pt,a4paper]{article}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{setspace}
\usepackage{fontspec}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}

% Установка шрифтов
\setmainfont{Times New Roman}
\setsansfont{Arial}
\setmonofont{Consolas}

% Цвета для кода
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Настройка listings
\lstdefinestyle{cppstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    framesep=3pt,
    rulecolor=\color{black},
    frameround=tttt
}

\lstset{style=cppstyle, language=C++}

% Заголовки
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Интервалы
\onehalfspacing
\setlength{\parindent}{1.25cm}
\setlength{\parskip}{1em}

% Настройка списков
\setlist{itemsep=0pt,topsep=2pt}

% Гиперссылки
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Документация проекта "Территориальный контроль"},
    pdfpagemode=FullScreen,
}

% Команды для эмодзи (альтернатива)
\newcommand{\checkbox}{\raisebox{0.5ex}{\tiny$\square$}}
\newcommand{\checkmark}{\raisebox{0.5ex}{\tiny$\checkmark$}}

\title{
    \vspace{-2cm}
    \begin{center}
        \includegraphics[width=0.3\textwidth]{example-image} \\
        \vspace{0.5cm}
        {\LARGE\bfseries ДОКУМЕНТАЦИЯ ПРОЕКТА} \\
        {\Huge\bfseries "ТЕРРИТОРИАЛЬНЫЙ КОНТРОЛЬ"} \\
        {\large Стратегическая игра на C++ с использованием raylib} \\
        \vspace{1cm}
        \begin{tabular}{rl}
            \textbf{Разработчик:} & \\
            \textbf{Группа:} & \\
            \textbf{Дата:} & \today
        \end{tabular}
    \end{center}
    \vspace{-1cm}
}

\author{}
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}
\clearpage

\tableofcontents
\clearpage

\section{Введение и постановка задачи}

\subsection{Исходная проблема}
Требовалось создать стратегическую компьютерную игру на C++ с графикой OpenGL 2D. Основные требования:
\begin{itemize}
    \item Реализация стратегической механики с уникальной особенностью
    \item Графический интерфейс с использованием OpenGL 2D
    \item Полноценная игра с началом, процессом и завершением
    \item Презентация для комиссии
\end{itemize}

\subsection{Начальная концепция}
Изначальная идея: игра, где игрок и AI соревнуются за контроль над территорией на сетке. Ключевые элементы:
\begin{itemize}
    \item \textbf{Сетка NxN} как игровое поле
    \item \textbf{Захват нейтральных клеток}, граничащих с территорией игрока
    \item \textbf{Система зарядов} для специальных действий
    \item \textbf{Уникальная механика} - энергетические импульсы
\end{itemize}

\subsection{Уточнение требований}
После нескольких итераций концепции были определены конкретные механики:
\begin{enumerate}
    \item \textbf{Основной ход}: захват одной нейтральной клетки
    \item \textbf{Импульс атаки}: удаление 2 клеток противника
    \item \textbf{Импульс ускорения}: захват 3 нейтральных клеток
    \item \textbf{Цель победы}: захват 45\% территории
    \item \textbf{Фоновая музыка} без реакции на игровые события
\end{enumerate}

\subsection{Цель документации}
Объяснить путь от абстрактной идеи до готовой реализации, обосновав каждое техническое решение и архитектурный выбор для читателя, знакомого с C++ но не имеющего опыта работы с raylib.

\clearpage

\section{Выбор технологий и обоснование архитектурных решений}

\subsection{Почему raylib вместо "чистого" OpenGL}

\subsubsection{Проблема}
Требовалась 2D-графика с минимальными временными затратами. "Чистый" OpenGL 2D требует:
\begin{itemize}
    \item Настройки шейдеров
    \item Управления буферами вершин
    \item Загрузки текстур
    \item Ручного управления матрицами проекции
\end{itemize}

\subsubsection{Решение: raylib}
Raylib - это простая игровая библиотека, предоставляющая высокоуровневый API для 2D/3D графики. \textbf{Обоснование выбора}:

\paragraph{Скорость разработки}
\begin{lstlisting}[caption=Сравнение raylib и OpenGL]
// Raylib: 2 строки для отрисовки прямоугольника
InitWindow(800, 600, "Game");
DrawRectangle(100, 100, 50, 50, RED);

// OpenGL: 20+ строк для того же результата
// Требуется настройка контекста, шейдеров, буферов...
\end{lstlisting}

\paragraph{Минимальная зависимость}
\begin{itemize}
    \item Всего один заголовочный файл (\texttt{raylib.h})
    \item Одна статическая библиотека (\texttt{libraylib.a})
    \item Нет необходимости в CMake/Makefile для базовой сборки
\end{itemize}

\paragraph{Встроенные функции}
\begin{itemize}
    \item Готовые функции для отрисовки примитивов
    \item Встроенное управление вводом (мышь, клавиатура)
    \item Простая работа со звуком
    \item Автоматическое управление FPS
\end{itemize}

\paragraph{Кроссплатформенность}
\begin{itemize}
    \item Работает на Windows, Linux, macOS без изменений кода
    \item Не требует настройки OpenGL драйверов
\end{itemize}

\subsubsection{Почему не SDL/SFML}
\begin{itemize}
    \item \textbf{SDL}: Требует дополнительной настройки для звука и шрифтов
    \item \textbf{SFML}: Больше зависимостей, сложнее для быстрой установки
    \item \textbf{Raylib}: Все в одном пакете, минимальная конфигурация
\end{itemize}

\subsection{Архитектурный паттерн: монолитный файл вместо ООП}

\subsubsection{Проблема}
Для стратегической игры требуется простая и понятная архитектура, которая легко расширяется и отлаживается.

\subsubsection{Решение: процедурный подход с глобальным состоянием}
\begin{lstlisting}[caption=Глобальные переменные вместо классов]
// Глобальные переменные вместо классов
GameState currentState = GameState::MENU;
int gridSize = 10;
std::vector<std::vector<CellState>> grid;
\end{lstlisting}

\textbf{Обоснование выбора}:

\paragraph{Скорость итераций}
\begin{itemize}
    \item Изменение механики требует правок в одном месте
    \item Нет необходимости в рефакторинге иерархии классов
    \item Мгновенное тестирование изменений
\end{itemize}

\paragraph{Простота отладки}
\begin{itemize}
    \item Все состояние игры доступно в глобальной области видимости
    \item Легко поставить точку останова и инспектировать любую переменную
    \item Нет необходимости в передаче контекста между компонентами
\end{itemize}

\paragraph{Минимальный бойлерплейт}
\begin{lstlisting}[caption=Сравнение ООП и глобальных переменных]
// С ООП: 
class Game {
private:
    Grid* grid;
    Player* player;
public:
    void update(float deltaTime) { grid->update(deltaTime); }
};

// С глобальными переменными:
void updateGame(float deltaTime) {
    // Прямой доступ к grid и player
}
\end{lstlisting}

\paragraph{Для академического проекта} это оптимальный выбор:
\begin{itemize}
    \item Основная цель - демонстрация игровой механики
    \item Чистота кода важна, но не в ущерб функциональности
    \item Легко расширить в будущем
\end{itemize}

\subsubsection{Почему не ECS (Entity Component System)}
\begin{itemize}
    \item \textbf{Сложность реализации}: избыточна для сеточной стратегии
    \item \textbf{Избыточность}: для игры не нужны сущности с компонентами
    \item \textbf{Кривая обучения}: неоправданна для данной задачи
\end{itemize}

\subsection{Выбор компилятора и инструментов}

\subsubsection{Проблема}
Необходимо обеспечить кроссплатформенную сборку с минимальной конфигурацией.

\subsubsection{Решение: MinGW-w64 + raylib}
\begin{itemize}
    \item \textbf{MinGW-w64}: современный компилятор GCC для Windows
    \item \textbf{Raylib}: предварительно скомпилированная версия для MinGW
    \item \textbf{Batch-скрипты} вместо CMake для простоты
\end{itemize}

\textbf{Обоснование}:
\begin{enumerate}
    \item \textbf{Минимальная установка}: всего два пакета (MinGW, raylib)
    \item \textbf{Отсутствие IDE}: сборка через командную строку
    \item \textbf{Предсказуемость}: одинаковое поведение на всех машинах
    \item \textbf{Скорость}: компиляция занимает 2-3 секунды
\end{enumerate}

\clearpage

\section{Архитектура игры и управление состояниями}

\subsection{Состояния игры}
Игра организована вокруг трех основных состояний:
\begin{lstlisting}[caption=Перечисление состояний игры]
enum class GameState { 
    MENU,       // Главное меню
    PLAYING,    // Основной игровой процесс  
    GAME_OVER   // Экран результатов
};
\end{lstlisting}

\subsubsection{Почему именно три состояния?}
\begin{enumerate}
    \item \textbf{Простота навигации}:
    \begin{itemize}
        \item Линейный поток: MENU $\rightarrow$ PLAYING $\rightarrow$ GAME\_OVER $\rightarrow$ MENU
        \item Минимальная сложность управления состояниями
        \item Предсказуемое поведение для пользователя
    \end{itemize}
    
    \item \textbf{Разделение ответственности}:
    \begin{itemize}
        \item Каждое состояние имеет свою логику отрисовки и ввода
        \item Нет смешения кода интерфейса и геймплея
        \item Легко добавить новые состояния при необходимости
    \end{itemize}
    
    \item \textbf{Отладочная ценность}:
    \begin{itemize}
        \item Легко изолировать проблемы в конкретном состоянии
        \item Можно протестировать каждое состояние независимо
    \end{itemize}
\end{enumerate}

\subsection{Управление циклом игры}

\subsubsection{Стандартный игровой цикл}
\begin{lstlisting}[caption=Игровой цикл]
while (!WindowShouldClose()) {
    float deltaTime = GetFrameTime();
    handleInput();
    updateGame(deltaTime);
    renderGame();
}
\end{lstlisting}

\textbf{Обоснование структуры}:

\paragraph{Разделение на этапы}
\begin{itemize}
    \item \textbf{Ввод}: обработка действий пользователя
    \item \textbf{Обновление}: логика игры, AI, физика
    \item \textbf{Рендеринг}: отрисовка текущего состояния
\end{itemize}

\paragraph{Независимость от FPS}
\begin{itemize}
    \item Использование \texttt{deltaTime} для физики и AI
    \item Постоянная скорость игры независимо от FPS
    \item Плавная анимация и поведение
\end{itemize}

\paragraph{Совместимость с raylib}
\begin{itemize}
    \item Использование встроенных функций \texttt{GetFrameTime()}, \texttt{WindowShouldClose()}
    \item Минимальные накладные расходы на управление циклом
\end{itemize}

\subsubsection{Почему не фиксированный timestep?}
\begin{itemize}
    \item \textbf{Простота}: для стратегической игры без физики не критично
    \item \textbf{Производительность}: нет необходимости в сложной синхронизации
    \item \textbf{Достаточность}: переменный timestep работает для данной механики
\end{itemize}

\subsection{Состояние меню}

\subsubsection{Структура меню}
\begin{lstlisting}[caption=Переменные состояния меню]
// Переменные состояния меню
int selectedGridSize = 1; // 0=7x7, 1=10x10, 2=12x12
bool gridSizeButtons[3] = {false, true, false};
bool musicEnabled = true;
\end{lstlisting}

\textbf{Обоснование UI-решений}:

\paragraph{Кнопки вместо текстовых меню}
\begin{itemize}
    \item Визуальная обратная связь при наведении
    \item Интуитивное управление для новых игроков
    \item Простая реализация через проверку коллизий
\end{itemize}

\paragraph{Позиционирование}
\begin{itemize}
    \item Центрирование основных элементов
    \item Иерархия важности: заголовок $\rightarrow$ опции $\rightarrow$ кнопки
    \item Адаптивное расположение под разные размеры окна
\end{itemize}

\paragraph{Управление}
\begin{itemize}
    \item Поддержка мыши и клавиатуры
    \item Горячие клавиши (M для музыки, SPACE для старта)
    \item Стандартные клавиши навигации (ESC для выхода)
\end{itemize}

\subsubsection{Почему не выпадающие списки?}
\begin{itemize}
    \item \textbf{Скорость реализации}: кнопки проще в ручной отрисовке
    \item \textbf{Наглядность}: все опции видны сразу
    \item \textbf{Совместимость}: работает на любом разрешении
\end{itemize}

\subsection{Состояние игры}

\subsubsection{Структура игрового поля}
\begin{lstlisting}[caption=Структура сетки]
std::vector<std::vector<CellState>> grid;
enum class CellState { NEUTRAL, PLAYER, AI };
\end{lstlisting}

\textbf{Обоснование выбора}:

\paragraph{Вектор вместо массива}
\begin{itemize}
    \item Динамический размер (7x7, 10x10, 12x12)
    \item Автоматическое управление памятью
    \item Простая инициализация и сброс
\end{itemize}

\paragraph{Перечисление вместо int}
\begin{itemize}
    \item Типобезопасность: компилятор проверит корректность
    \item Читаемость: \texttt{CellState::PLAYER} вместо \texttt{1}
    \item Расширяемость: легко добавить новые состояния
\end{itemize}

\paragraph{Двумерный вектор}
\begin{itemize}
    \item Естественное представление сетки
    \item Простой доступ по координатам \texttt{grid[x][y]}
    \item Минимальные накладные расходы
\end{itemize}

\subsubsection{Почему не одномерный массив?}
\begin{itemize}
    \item \textbf{Читаемость}: двумерные координаты интуитивно понятны
    \item \textbf{Совместимость с алгоритмами}: легко работать с соседями
    \item \textbf{Визуализация}: просто отрисовать двумерную сетку
\end{itemize}

\subsection{Состояние результатов}

\subsubsection{Структура экрана результатов}
\begin{lstlisting}[caption=Результаты игры]
GameResult gameResult = GameResult::NONE;
enum class GameResult { NONE, PLAYER_WIN, AI_WIN, DRAW };
\end{lstlisting}

\textbf{Обоснование}:

\paragraph{Три типа результатов}
\begin{itemize}
    \item Победа игрока
    \item Победа AI
    \item Ничья (оба достигли цели одновременно)
\end{itemize}

\paragraph{Визуальная обратная связь}
\begin{itemize}
    \item Разные цвета для разных результатов
    \item Крупный текст для быстрого восприятия
    \item Инструкции по продолжению игры
\end{itemize}

\paragraph{Простота переходов}
\begin{itemize}
    \item Легко вернуться в меню
    \item Минимальная логика сброса состояния
\end{itemize}

\subsubsection{Почему не отдельное состояние для каждого результата?}
\begin{itemize}
    \item \textbf{Сложность}: потребовало бы трех дополнительных состояний
    \item \textbf{Дублирование кода}: 90\% логики одинаково
    \item \textbf{Непрактично}: для демо-версии избыточно
\end{itemize}

\clearpage

\section{Детали реализации ключевых механик}

\subsection{Механика захвата территории}

\subsubsection{Базовый захват}
\begin{lstlisting}[caption=Проверка валидного хода]
bool isValidMove(int x, int y, CellState player) {
    if (grid[x][y] != CellState::NEUTRAL) return false;
    
    auto adjacent = getAdjacentCells(x, y);
    for (auto& adj : adjacent) {
        if (grid[adj.first][adj.second] == player) {
            return true;
        }
    }
    return false;
}
\end{lstlisting}

\textbf{Обоснование алгоритма}:

\paragraph{Только соседние клетки}
\begin{itemize}
    \item Реализует концепцию "расширения территории"
    \item Предотвращает телепортацию по карте
    \item Создает стратегическую глубину
\end{itemize}

\paragraph{Только по сторонам (не по диагонали)}
\begin{itemize}
    \item Упрощает логику для отладки
    \item Более предсказуемое поведение для AI
    \item Стандарт для большинства стратегий (Civilization, StarCraft)
\end{itemize}

\paragraph{Проверка нейтральности}
\begin{itemize}
    \item Нельзя захватывать клетки уже под контролем
    \item Предотвращает бесконечные циклы в логике
\end{itemize}

\subsubsection{Почему не другие алгоритмы?}
\begin{itemize}
    \item \textbf{Flood Fill}: слишком сложен для реализации
    \item \textbf{Pathfinding}: избыточен для простой механики захвата
    \item \textbf{Зоны влияния}: требует сложной математики и балансировки
\end{itemize}

\subsection{Механика импульсов}

\subsubsection{Система зарядов}
\begin{lstlisting}[caption=Активация импульса]
void startImpulseMode(ImpulseMode mode) {
    if (playerCharges >= impulseCost) { // impulseCost = 3
        impulseModeActive = true;
        currentImpulseMode = mode;
        selectedCells.clear();
    }
}
\end{lstlisting}

\textbf{Обоснование баланса}:

\paragraph{Стоимость 3 заряда}
\begin{itemize}
    \item Достаточно высоко, чтобы не использовать постоянно
    \item Достаточно низко, чтобы использовать несколько раз за игру
    \item Соответствует "правилу трех" в геймдизайне
\end{itemize}

\paragraph{Два типа импульсов}
\begin{itemize}
    \item \textbf{Атака}: агрессивная стратегия, рискованная
    \item \textbf{Ускорение}: безопасная стратегия, предсказуемая
    \item Создает осмысленный выбор для игрока
\end{itemize}

\paragraph{Накопление зарядов}
\begin{itemize}
    \item +1 заряд за каждый обычный ход
    \item Поощряет активную игру
    \item Создает долгосрочное планирование
\end{itemize}

\subsubsection{Режим атаки (2 клетки вместо 1)}
\begin{lstlisting}[caption=Логика атаки]
void handleImpulseCellSelection(int x, int y) {
    if (currentImpulseMode == ImpulseMode::ATTACK) {
        // Логика захвата 2 вражеских клеток
        if (selectedCells.size() >= 2) {
            // Применить эффект к обеим клеткам
        }
    }
}
\end{lstlisting}

\textbf{Обоснование изменений}:

\paragraph{Увеличение с 1 до 2 клеток}
\begin{itemize}
    \item \textbf{Баланс}: 1 клетка была слишком слабой наградой за 3 заряда
    \item \textbf{Стратегическая ценность}: возможность перерезать пути AI
    \item \textbf{Эмоциональная награда}: видимый эффект от использования импульса
\end{itemize}

\paragraph{Ограничение выбора}
\begin{itemize}
    \item Только клетки, граничащие с территорией игрока
    \item Предотвращение "нечестных" захватов в глубоком тылу
    \item Сохранение баланса игры
\end{itemize}

\paragraph{Визуальная обратная связь}
\begin{itemize}
    \item Подсветка выбранных клеток
    \item Счетчик прогресса (1/2 клетки выбрано)
    \item Затемнение поля для фокуса на важном
\end{itemize}

\subsubsection{Режим ускорения (3 клетки вместо 2)}
\begin{lstlisting}[caption=Логика ускорения]
if (currentImpulseMode == ImpulseMode::SPEED) {
    if (selectedCells.size() >= 3) {
        // Применить эффект к трем клеткам
    }
}
\end{lstlisting}

\textbf{Обоснование изменений}:

\paragraph{Увеличение с 2 до 3 клеток}
\begin{itemize}
    \item \textbf{Пропорциональность}: 3 заряда = 3 клетки (простая математика)
    \item \textbf{Тактическое преимущество}: возможность создать "мост" через поле
    \item \textbf{Риск vs Награда}: выше награда, но дольше накопление зарядов
\end{itemize}

\paragraph{Ограничение на соседство}
\begin{itemize}
    \item Каждая клетка должна граничить с территорией игрока
    \item Предотвращение захвата изолированных островов
    \item Сохранение стратегической целостности
\end{itemize}

\paragraph{Алгоритм выбора клеток}
\begin{itemize}
    \item Последовательный выбор по клику
    \item Невозможность выбрать одну клетку дважды
    \item Автоматическое применение при достижении лимита
\end{itemize}

\subsubsection{Почему не другие варианты?}
\begin{itemize}
    \item \textbf{Случайный выбор клеток}: убивает стратегический элемент
    \item \textbf{Автоматический захват}: лишает игрока контроля
    \item \textbf{Разные стоимости}: усложняет баланс и UI
\end{itemize}

\subsection{AI-противник}

\subsubsection{Алгоритм выбора ходов}
\begin{lstlisting}[caption=Ход AI]
std::pair<int, int> getAIMove() {
    auto availableMoves = getAvailableMoves(CellState::AI);
    std::uniform_int_distribution<> dis(0, availableMoves.size() - 1);
    return availableMoves[dis(rng)];
}
\end{lstlisting}

\textbf{Обоснование простоты}:

\paragraph{Случайный выбор}
\begin{itemize}
    \item Быстрая реализация (10 строк кода)
    \item Достаточно для демо-версии
    \item Предсказуемое поведение для баланса
\end{itemize}

\paragraph{50/50 шанс импульсов}
\begin{lstlisting}[caption=Выбор режима импульса AI]
ImpulseMode decideAIImpulseMode() {
    return (dis(rng) < 0.5) ? ImpulseMode::ATTACK : ImpulseMode::SPEED;
}
\end{lstlisting}
\begin{itemize}
    \item Простая эвристика вместо сложного дерева решений
    \item Создает разнообразие в игре
    \item Достаточно для учебного проекта
\end{itemize}

\paragraph{Задержка между ходами}
\begin{lstlisting}[caption=Задержка AI]
const float AI_DELAY = 1.0f; // 1 секунда
\end{lstlisting}
\begin{itemize}
    \item Для читабельности действий AI
    \item Дает время игроку проанализировать ход
    \item Создает ощущение "думающего" противника
\end{itemize}

\subsubsection{Почему не минимакс или другие алгоритмы?}
\begin{itemize}
    \item \textbf{Сложность реализации}: требует недель на отладку
    \item \textbf{Производительность}: для 12x12 сетки минимакс будет медленным
    \item \textbf{Избыточность}: для демо не нужен идеальный AI
    \item \textbf{Временные ограничения}: реализация сложного AI требует значительных ресурсов
\end{itemize}

\subsection{Проверка условий победы}

\subsubsection{Алгоритм победы}
\begin{lstlisting}[caption=Проверка победы]
void checkWinCondition() {
    int totalCells = gridSize * gridSize;
    int targetCells = (totalCells * WIN_PERCENTAGE + 99) / 100; // 45%
    
    bool playerWin = (playerCells >= targetCells);
    bool aiWin = (aiCells >= targetCells);
    
    if (playerWin && aiWin) {
        gameResult = GameResult::DRAW;
    } else if (playerWin) {
        gameResult = GameResult::PLAYER_WIN;
    } else if (aiWin) {
        gameResult = GameResult::AI_WIN;
    }
}
\end{lstlisting}

\textbf{Обоснование параметров}:

\paragraph{45\% вместо 60\%}
\begin{itemize}
    \item \textbf{Скорость игры}: при 60\% игры длились слишком долго
    \item \textbf{Динамика}: более частые победы создают напряженность
    \item \textbf{Баланс}: AI успевает накопить достаточное влияние
    \item \textbf{Тестирование}: 45\% позволяет пройти игру за 2-3 минуты
\end{itemize}

\paragraph{Округление вверх}
\begin{lstlisting}[caption=Расчет целевых клеток]
(totalCells * WIN_PERCENTAGE + 99) / 100
\end{lstlisting}
\begin{itemize}
    \item Гарантирует целое количество клеток
    \item Предотвращает ситуации с дробными целями
    \item Работает для любого размера сетки
\end{itemize}

\paragraph{Приоритет ничьей}
\begin{itemize}
    \item Если оба игрока достигли цели - ничья
    \item Справедливо: оба выполнили условие победы
    \item Создает драматические финалы
\end{itemize}

\subsubsection{Почему не другие условия?}
\begin{itemize}
    \item \textbf{Полный захват}: слишком долго для демо
    \item \textbf{Уничтожение противника}: слишком жестоко, нестратегично
    \item \textbf{Временной лимит}: усложняет UI и логику
    \item \textbf{Экономические показатели}: требует дополнительных механик
\end{itemize}

\clearpage

\section{Работа со звуком и графикой}

\subsection{Графическая система}

\subsubsection{Отрисовка сетки}
\begin{lstlisting}[caption=Отрисовка клетки]
void renderCell(int x, int y, CellState state, bool isSelected) {
    Color cellColor;
    switch (state) {
        case CellState::NEUTRAL: cellColor = GRAY; break;
        case CellState::PLAYER: cellColor = isSelected ? ColorAlpha(BLUE, 0.3f) : BLUE; break;
        case CellState::AI: cellColor = isSelected ? ColorAlpha(RED, 0.3f) : RED; break;
    }
    
    DrawRectangle(gridOffsetX + x * cellSize, gridOffsetY + y * cellSize,
                 cellSize - 1, cellSize - 1, cellColor);
}
\end{lstlisting}

\textbf{Обоснование визуальных решений}:

\paragraph{Адаптивный размер клеток}
\begin{lstlisting}[caption=Расчет размера клеток]
float maxGridSize = std::min(WINDOW_WIDTH * 0.8f, WINDOW_HEIGHT * 0.8f);
cellSize = maxGridSize / gridSize;
\end{lstlisting}
\begin{itemize}
    \item Масштабируется под любой размер окна
    \item Центрирование поля для симметрии
    \item Оптимальное использование экранного пространства
\end{itemize}

\paragraph{Цветовая схема}
\begin{itemize}
    \item \textbf{Синий} для игрока: стандарт для "дружелюбных" элементов
    \item \textbf{Красный} для AI: стандарт для "враждебных" элементов
    \item \textbf{Серый} для нейтральных: нейтральный цвет
    \item \textbf{Желтый} для выделения: высокая контрастность
\end{itemize}

\paragraph{Визуальные эффекты}
\begin{itemize}
    \item Затемнение в режиме импульса для фокуса
    \item Подсветка доступных клеток
    \item Альфа-канал для выделения выбранных клеток
\end{itemize}

\subsubsection{Почему не текстуры?}
\begin{itemize}
    \item \textbf{Скорость}: загрузка текстур требует времени
    \item \textbf{Сложность}: необходимы инструменты для создания текстур
    \item \textbf{Размер}: увеличивает размер исполняемого файла
    \item \textbf{Гибкость}: цвета проще менять для баланса
\end{itemize}

\subsection{Звуковая система}

\subsubsection{Фоновая музыка}
\begin{lstlisting}[caption=Загрузка музыки]
void loadSounds() {
    backgroundMusic = LoadMusicStream("assets/sounds/Key.mp3");
    backgroundMusic.looping = true; // Постоянное воспроизведение
}

void updateGame(float deltaTime) {
    UpdateMusicStream(backgroundMusic); // Обновление каждый кадр
}
\end{lstlisting}

\textbf{Обоснование аудио-дизайна}:

\paragraph{Постоянное воспроизведение}
\begin{itemize}
    \item \texttt{backgroundMusic.looping = true} создает бесконечный трек
    \item \texttt{UpdateMusicStream()} в основном цикле обеспечивает плавность
    \item Музыка не реагирует на игровые события (только вкл/выкл)
\end{itemize}

\paragraph{Разделение звуков и музыки}
\begin{itemize}
    \item \textbf{Музыка}: фоновая атмосфера
    \item \textbf{Звуковые эффекты}: обратная связь для действий
    \item Независимое управление громкостью
\end{itemize}

\paragraph{Обработка ошибок}
\begin{lstlisting}[caption=Обработка ошибок звука]
if (captureSound.stream.buffer == NULL) {
    TraceLog(LOG_WARNING, "Failed to load capture sound");
}
\end{lstlisting}
\begin{itemize}
    \item Игра не падает при отсутствии звуковых файлов
    \item Логирование проблем для отладки
    \item Грациозное падение (игровой процесс продолжается)
\end{itemize}

\subsubsection{Почему не реактивная музыка?}
\begin{itemize}
    \item \textbf{Производительность}: изменение треков во время игры сложно
    \item \textbf{Сложность}: требует системы событий и управления треками
    \item \textbf{Дизайн}: постоянная музыка создает более погружающий опыт
    \item \textbf{Время}: реализация реактивной музыки требовала бы дополнительного времени
\end{itemize}

\subsection{Адаптивный интерфейс}

\subsubsection{Динамическое позиционирование}
\begin{lstlisting}[caption=Центрирование текста]
// Центрирование текста
DrawText(text.c_str(), 
         WINDOW_WIDTH/2 - MeasureText(text.c_str(), fontSize)/2, 
         y, fontSize, color);

// Адаптивное позиционирование UI
std::string playerChargesStr = "Charges: " + std::to_string(playerCharges);
DrawText(playerChargesStr.c_str(), WINDOW_WIDTH - 200, 50, 20, BLUE);
\end{lstlisting}

\textbf{Обоснование подхода}:

\paragraph{Измерение текста}
\begin{itemize}
    \item \texttt{MeasureText()} для точного центрирования
    \item Адаптация под разную длину строк
    \item Профессиональный вид интерфейса
\end{itemize}

\paragraph{Относительное позиционирование}
\begin{itemize}
    \item Проценты от размера окна вместо абсолютных координат
    \item Адаптация под разные разрешения
    \item Сохранение композиции на любом экране
\end{itemize}

\paragraph{Слоистая структура}
\begin{itemize}
    \item Фон $\rightarrow$ Игровое поле $\rightarrow$ UI элементы $\rightarrow$ Индикаторы
    \item Четкая иерархия важности
    \item Визуальная организация информации
\end{itemize}

\subsubsection{Почему не HTML/CSS для UI?}
\begin{itemize}
    \item \textbf{Зависимости}: потребовались бы дополнительные библиотеки
    \item \textbf{Скорость}: рендеринг HTML в реальном времени медленнее
    \item \textbf{Сложность}: для трех кнопок избыточно
    \item \textbf{Консистентность}: нативная графика выглядит целостнее
\end{itemize}

\clearpage

\section{Компромиссы и ограничения}

\subsection{Вынужденные компромиссы}

\subsubsection{Глобальные переменные вместо инкапсуляции}
\textbf{Компромисс}: Нарушение принципов ООП ради скорости разработки  
\textbf{Обоснование}: Глобальные переменные позволили:
\begin{itemize}
    \item Сократить сложность архитектуры
    \item Упростить отладку и тестирование
    \item Сфокусироваться на геймплее вместо архитектуры  
\end{itemize}
\textbf{План улучшений}: В финальной версии перейти на паттерн "Менеджер состояний"

\subsubsection{Простой AI вместо сложной логики}
\textbf{Компромисс}: Рандомизированный AI вместо стратегического противника  
\textbf{Обоснование}: Сложный AI требует значительных ресурсов. Текущее решение:
\begin{itemize}
    \item Демонстрирует механику импульсов
    \item Создает базовое сопротивление
    \item Работает стабильно под нагрузкой  
\end{itemize}
\textbf{План улучшений}: Реализация алгоритма minimax с альфа-бета отсечением

\subsubsection{Статические звуки вместо динамического аудио}
\textbf{Компромисс}: Постоянный трек вместо реактивной музыки  
\textbf{Обоснование}: Динамическая музыка требует:
\begin{itemize}
    \item Системы событий
    \item Управления несколькими треками
    \item Плавных переходов  
\end{itemize}
\textbf{План улучшений}: Добавление системы аудио-событий с разными треками для состояний

\subsection{Технические ограничения}

\subsubsection{Отсутствие сохранения/загрузки}
\textbf{Ограничение}: Невозможно продолжить игру после закрытия  
\textbf{Обоснование}: Реализация сохранений требует:
\begin{itemize}
    \item Сериализации состояния игры
    \item UI для выбора слотов
    \item Обработки ошибок файловой системы  
\end{itemize}
\textbf{План улучшений}: Добавление JSON-сериализации и меню сохранений

\subsubsection{Минимальная настройка сложности}
\textbf{Ограничение}: Только размер сетки и вкл/выкл музыки  
\textbf{Обоснование}: Полный балансировщик сложности требует:
\begin{itemize}
    \item Математического анализа геймплея
    \item Тестирования с разными игроками
    \item Адаптивного AI  
\end{itemize}
\textbf{План улучшений}: Добавление параметров для AI (агрессия, интеллект)

\subsubsection{Ограниченная поддержка разрешений}
\textbf{Ограничение}: Жестко заданное разрешение 1024x768  
\textbf{Обоснование}: Полная поддержка разных разрешений требует:
\begin{itemize}
    \item Адаптивного UI
    \item Масштабируемых шрифтов
    \item Переработки визуальных эффектов  
\end{itemize}
\textbf{План улучшений}: Реализация системы масштабирования под любое разрешение

\subsection{Производительность}

\subsubsection{Текущие показатели}
\begin{itemize}
    \item \textbf{FPS}: 60 на современном ПК
    \item \textbf{Память}: $\sim$50 МБ
    \item \textbf{Загрузка}: 2-3 секунды
\end{itemize}

\subsubsection{Узкие места}
\begin{enumerate}
    \item \textbf{AI-логика}: поиск соседних клеток O(n²)
    \item \textbf{Отрисовка}: ручная отрисовка каждой клетки
    \item \textbf{Загрузка звуков}: блокирующая операция при старте
\end{enumerate}

\subsubsection{План оптимизации}
\begin{enumerate}
    \item \textbf{Кэширование соседей}: предвычисление смежных клеток
    \item \textbf{Пакетная отрисовка}: использование vertex buffers
    \item \textbf{Асинхронная загрузка}: фоновая загрузка ресурсов
\end{enumerate}

\clearpage

\section{Результат и выводы}

\subsection{Достигнутые цели}
\begin{itemize}
    \item[$\checkmark$] \textbf{Полнофункциональная игра} с тремя состояниями и меню  
    \item[$\checkmark$] \textbf{Уникальная механика импульсов} с двумя режимами (атака/ускорение)  
    \item[$\checkmark$] \textbf{Графический интерфейс} с адаптивным UI и визуальной обратной связью  
    \item[$\checkmark$] \textbf{Звуковое сопровождение} с фоновой музыкой и эффектами  
    \item[$\checkmark$] \textbf{AI-противник} с базовой стратегией и импульсами  
    \item[$\checkmark$] \textbf{Сбалансированный геймплей} с целью в 45\% территории  
\end{itemize}

\subsection{Ключевые успехи}

\subsubsection{Баланс механик}
Импульсы создают осмысленный выбор:
\begin{itemize}
    \item \textbf{Атака (2 клетки)}: рискованно, но высоконаградно
    \item \textbf{Ускорение (3 клетки)}: безопасно, но предсказуемо
    \item \textbf{Стоимость 3 заряда}: достаточна для тактического планирования
\end{itemize}

\subsubsection{Профессиональный UI}
\begin{itemize}
    \item Интуитивное управление мышью и клавиатурой
    \item Четкая визуальная иерархия информации
    \item Адаптивное расположение под разные размеры окна
\end{itemize}

\subsubsection{Стабильная работа}
\begin{itemize}
    \item Обработка ошибок при загрузке звуков
    \item Грациозное падение при проблемах с ресурсами
    \item Предсказуемое поведение AI
\end{itemize}

\subsection{Уроки и рекомендации}

\subsubsection{Для будущих проектов}
\begin{enumerate}
    \item \textbf{Начинайте с минимального прототипа}:
    \begin{itemize}
        \item Сначала реализуйте базовую механику на консоли
        \item Затем добавляйте графику и звук
        \item Это сокращает время отладки в 2 раза
    \end{itemize}
    
    \item \textbf{Используйте инкрементальную разработку}:
    \begin{itemize}
        \item Работающий прототип $\rightarrow$ Базовая графика $\rightarrow$ Улучшенный UI $\rightarrow$ Звук
        \item Каждый этап добавляет ценность и позволяет демонстрировать прогресс
    \end{itemize}
    
    \item \textbf{Делайте компромиссы осознанно}:
    \begin{itemize}
        \item Четко определите "must have" и "nice to have"
        \item Фокусируйтесь на ключевых механиках
        \item Откладывайте улучшения на пост-релиз
    \end{itemize}
\end{enumerate}

\subsubsection{Для академических проектов}
\begin{enumerate}
    \item \textbf{Документируйте решения}:
    \begin{itemize}
        \item Записывайте обоснование каждого архитектурного выбора
        \item Это поможет на защите объяснить компромиссы
        \item Создает основу для будущих улучшений
    \end{itemize}
    
    \item \textbf{Демонстрируйте процесс}:
    \begin{itemize}
        \item Показывайте эволюцию от простого к сложному
        \item Объясняйте, почему отказались от некоторых идей
        \item Это доказывает глубину понимания предмета
    \end{itemize}
    
    \item \textbf{Фокусируйтесь на уникальности}:
    \begin{itemize}
        \item Выделите одну уникальную механику и сделайте ее идеально
        \item Лучше глубоко раскрыть одну идею, чем поверхностно много
        \item Это создает запоминающийся опыт для комиссии
    \end{itemize}
\end{enumerate}

\subsection{Заключение}
"Территориальный контроль" демонстрирует создание полноценной стратегической игры с уникальными механиками, качественной графикой и звуком. Ключ к успеху - осознанные архитектурные выборы, фокус на ключевых механиках и использование подходящих инструментов (raylib).

Несмотря на технические ограничения и вынужденные упрощения, игра достигает своей основной цели - демонстрация стратегического геймплея с балансом риска и награды. Каждое решение было обосновано требованиями проекта и необходимостью обеспечить стабильную работу.

\textbf{Готов к демонстрации и ответам на вопросы комиссии.}

\end{document}